---
title:  "[공부 노트] #9"
excerpt: "4월 2주차 공부 노트"

categories:
  - Study
tags:
  - Study Note
use_math: true
last_modified_at: 2021-04-11T12:00:00
---

## OSI 7계층
국제표준화기구(ISO)에서 표준화된 네트워크 구조를 제시하여 통신 업체 장비와 통신 주체 사이의 호환이 가능하도록 한다.

- 응용 계층 : 사용자가 네트워크에 접근할 수 있도록 인터페이스를 제공한다.
  - 프로토콜 : HTTP, FTP, DNS
- 표현 계층 : 데이터의 포맷/확장자를 결정/변환한다.
- 세션 계층 : 응용프로세스가 통신을 관리하는 방법을 제공한다. 즉, 네트워크로 통신하는 시스템 사이의 상호작용을 설정/유지한다.
  - 프로토콜 : SSH, TLS
- 전송 계층 : **프로세스**간의 통신을 담당하며 오류 및 흐름제어를 수행한다.
  - 프로토콜 : TCP, UDP
- 네트워크 계층 : 논리적인 주소를 지원하며 데이터가 목적지까지 전달되도록 하는 역할을 수행한다.
  - 프로토콜 : IP, ICMP, ARM
- 데이터 계층 : 물리적으로 연결된 호스트 사이의 통신을 담당한다.
  - 프로토콜 : 이더넷
- 물리계층 : 통신 케이블을 통해 전기 신호(비트 스트림)을 전송한다.


## TCP/IP 4계층
실제로 오늘날까지 인터넷에서 정보를 주고 받는 통신 규약은 TCP/IP 4계층이며, OSI 7계층보다 먼저 개발되기도 했다.

- 응용 계층 : OSI 7계층의 응용 계층 + 표현 계층 + 세션 계층
- 전송 계층 : OSI 7계층의 전송 계층
- 인터넷 계층 : OSI 7계층의 네트워크 계층
- 네트워크 엑세스 계층: OSI 7계층의 물리계층 + 데이터 계층

## DNS
DNS(Domain Name System)이란 기억하기 쉽게 문자로 이루어진 도메인을 컴퓨터가 처리할 수 있는 ip주소로 바꾸어주는 것이다.  
  
**과정**  
1. 웹 브라우저에 www.naver.com을 입력하면 해당 url이 문법에 맞는지 검사한다.
2. 문법에 맞지 않으면 웹 브라우저는 기본 검색 엔진으로 검색을 요청하고, 문법에 맞으면 DNS(Domain Name Server)를 조회한다.
  - 문법: 프로토콜 :// 도메인 : 포트 / 자원경로 ? 파라미터 # 앵커
3. DNS에 요청을 보내기 전, 브라우저와 로컬(윈도우의 경우 hosts파일)에 캐시된 데이터가 있는지 확인하고, 없다면 Local DNS에 요청한다.
4. Local DNS에 www.naver.com의 ip주소가 없으면 Root DNS에 질의한다.
5. Root DNS는 .com 도메인을 관리하는 DNS 서버의 ip주소를 알려주고, Local DNS는 그것으로 다시 도메인을 질의한다.
6. com DNS는 naver.com 도메인을 관리하는 DNS 서버의 ip주소를 알려주고, Local DNS는 그것으로 다시 도메인을 질의한다.
7. naver.com DNS는 www.naver.com의 ip주소를 알려주고, Local DNS는 ip정보를 반환해준다.

여기서 Local DNS에 보내는 질의는 recursive query(== 니가 알아서 찾아와)이고, Local DNS가 루트도메인, com 도메인을 거치며 열심히 찾는건 iterative query라고 한다.


## TCP와 UDP
**TCP**  
장치들 사이의 논리적인 접속을 위해 연결을 설정하여 신뢰성을 보장하는 연결형 프로토콜이다.  

- 흐름제어 : 데이터 처리 속도를 조절하여 수신자의 버퍼 오버플로우를 방지한다. 수신자가 window size값을 조정하여 수신량을 조절할 수 있다. 이 윈도우 크기는 3 way handshaking 과정에서 수신자의 window size에 맞춰 송신자의 window size가 결정된다. 즉, 받을 수 있는 크기만큼 보내는 크기를 정하는 것이다
  - stop and wait : 전송 패킷에 대해서 응답을 받아야지만 다음 패킷을 보낸다
  - window sliding : 송신자는 윈도우 사이즈에 포함되는 패킷들을 계속해서 보내고, 만약 ack를 수신하면 ack한 만큼 윈도우를 sliding한다
- 혼잡제어 : 네트워크 안의 패킷 수가 넘치게 증가하지 않도록 방지한다
  - AIMD : 패킷을 보내고 문제없으면 윈도우사이즈 1씩 증가. 문제 있으면 윈도우사이즈 절반
  - slow start : threshold까지는 지수적으로 증가하고, 문제가 생기면 1로 줄인다
  - Fast Retransmit : 3 ack duplicated 발생 시 타임아웃 시간이 지나지 않더라도 해당 패킷을 재전송한다
  - Fast Recovery : 3 ack duplicated 발생시 윈도우 크기를 1로 줄이는 것이 아니라 AIMD방식처럼 반으로 줄인다. 타임아웃 발생시에는 똑같이 1로 줄이는데, 혼잡 상황을 구분하여 대응하는 것이다.


**UDP**  
비연결형 프로토콜 port만 확인하여 소켓을 송수신한다. 전송의 신뢰성은 보장되지 않지만, 패킷의 오버헤드가 적어 네트워크 부하가 감소한다.

- 오류검출 : 오류 검출 필드(체크섬)를 이용하여 무결성 검사

음성/비디오를 이용한 실시간 스트리밍 서비스나 온라인 게임 등 실시간이 보장되어야 하는 서비스에 사용되며, HTTP/3에서는 UDP기반의 프로토콜 QUIC(Quick UDP Internet Connection)을 사용하기도 한다.[(참고링크)](https://evan-moon.github.io/2019/10/08/what-is-http3/)

## MTU
MTU(Maximum Transmission Unit)은 전송될 수 있는 패킷 또는 프레임의 최대 크기를 말하며, MSS(Maximum Segment Size)는 ip헤더와 tcp헤더를 제외하고 전송할 수 있는 사용자 데이터의 최대 크기를 말한다. 이더넷 환경에서의 MTU는 기본적으로 1500Byte 인데, 이 때 MSS는 다음과 같다.
```
1500 - 20(ip헤더) - 20(tcp헤더) = 1460 byte
```

## 3-way hand shake, 4-way hand shake
**3-way hand shake**  
1. 클라이언트가 서버에 접속을 요청하는 SYN(a)패킷을 보내고 SYN_SENT 상태가 된다.
2. 서버는 LISTEN상태에 있다가 클라이언트의 패킷을 받고 SYN(b)/ACK(a+1) 패킷을 보내고 SYN_RECEIVED 상태가 된다.
3. 클라이언트는 서버로부터 패킷을 받고 ACK(b+1)을 서버로 보내고 연결이 성립한다.

위에서 설명한 SYN, ACK와 같은 정보는 6비트의 TCP헤더의 플래그(control bit)로 표시한다. 그리고 만약 HTTPS와 같이 TLS를 사용하는 경우 추가적인 handshake과정이 발생한다.  
  
**SSL(TLS) hand shake**
1. Client Hello : 클라이언트가 생성한 랜덤값, 가능한 암호화 방식 목록, 세션 id 등 정보를 전달한다
2. Server Hello : 서버가 생성한 랜덤값, 가능한 암호화 방식 중 선택한 암호화 방식, **인증서**정보 등을 전달한다.  
여기서 인증서란, 인증된 기관(Certificate Authority, CA)에서 본인들의 개인키로 서비스 정보와 서버의 공개키를 암호화한 것이다.
3. 클라이언트는 CA의 공개키를 이용하여 인증서가 CA에 의해 발급받은 것인지 확인하고, 서버의 공개키를 획득한다(인증서 내부에 서버의 공개키가 없다면, 서버가 직접 전달한다). 서버와 클라이언트가 생성한 랜덤값 2개를 이용하여 **대칭키**를 만들고, 서버의 공개키로 암호화하여 서버로 전송한다.
4. 서버는 암호화된 대칭키를 자신의 개인키로 복호화하여 대칭키를 얻는다. 이 대칭키를 세션키로 사용하여 이후 통신에서 계속 사용한다.

**4-way hand shake**  
1. 클라이언트가 서버에 연결을 종료하겠다는 FIN 패킷을 전송한다.
2. 서버는 패킷을 받고 ACK를 보낸 뒤 본인의 통신이 끝날 때까지 잠시 기다린다.
3. 데이터를 모두 보냈으면 클라이언트에게 FIN 패킷을 전송한다.
4. 클라이언트는 패킷을 받고 ACK패킷을 보낸 뒤 서버로 부터 도착하지 않은 패킷을 대비하여 잠시 세션을 유지하다가 종료한다.

## TFO(TCP Fast Open)
TCP통신을 위해 항상 3-way hand shake 과정을 거쳐야만 하는데, 이때 통신의 효율성을 증대시키기 위해 나온 방법이다. 쿠키를 이용해서 3-way hand shake 과정 중에도 데이터를 주고받는다.

1. 클라이언트가 쿠키를 요청하는 SYN을 보낸다.
2. 서버에서 쿠키를 만들고, 쿠키와 함께 SYN/ACK를 보낸다.
3. 클라이언트가 쿠키를 캐시해두고, ACK를 보낸다.

이후 통신에서는 다음과 같은 과정을 거친다.

1. 클라이언트가 SYN + 쿠키 + **데이터**를 보낸다.
2. 서버는 쿠키를 검증하고, 데이터를 처리한다. SYN/ACK를 보내고 이후 응답을 받기 전부터 클라이언트에게 패킷을 보낼 수 있다.
3. 클라이언트가 ACK를 보낸다. 이 때, 서버 측에서는 이미 처음에 받은 데이터에 대한 응답을 보내고 있을 수 있다.

이렇게 3-way hand shake 과정 도중에 데이터를 주고 받을 수 있게 함으로써 효율성을 증대시킨다.
  
  


참고문헌
> https://evan-moon.github.io/2019/10/08/what-is-http3/  
https://aws-hyoh.tistory.com/39  

