---
title:  "[프로그래머스] 스타 수열"
excerpt: "월간 코드 챌린지 시즌1"

categories:
  - Algorithm
tags:
  - Programmers
comments: false
last_modified_at: 2021-04-29T12:00:00
---
### 문제 설명
다음과 같은 것들을 정의합니다.

어떤 수열 x의 부분 수열(Subsequence)이란, x의 몇몇 원소들을 제거하거나 그러지 않고 남은 원소들이 원래 순서를 유지하여 얻을 수 있는 새로운 수열을 말합니다.

- 예를 들어, [1,3]은 [1,2,3,4,5]의 부분수열입니다. 원래 수열에서 2, 4, 5를 제거해서 얻을 수 있기 때문입니다.

다음과 같은 조건을 모두 만족하는 수열 x를 스타 수열이라고 정의합니다.

- x의 길이가 2 이상의 짝수입니다. (빈 수열은 허용되지 않습니다.)
- x의 길이를 2n이라 할 때, 다음과 같은 n개의 집합 {x[0], x[1]}, {x[2], x[3]}, ..., {x[2n-2], x[2n-1]} 의 교집합의 원소의 개수가 1 이상입니다.
- x[0] != x[1], x[2] != x[3], ..., x[2n-2] != x[2n-1] 입니다.
- 예를 들어, [1,2,1,3,4,1,1,3]은 스타 수열입니다. {1,2}, {1,3}, {4,1}, {1,3} 의 교집합은 {1} 이고, 각 집합 내의 숫자들이 서로 다르기 때문입니다.

1차원 정수 배열 a가 매개변수로 주어집니다. a의 모든 부분 수열 중에서 가장 길이가 긴 스타 수열의 길이를 return 하도록 solution 함수를 완성해주세요. 이때, a의 모든 부분 수열 중에서 스타 수열이 없다면, 0을 return 해주세요.

### 제한사항
- a의 길이는 1 이상 500,000 이하입니다.
- a의 모든 수는 0 이상 (a의 길이) 미만입니다.

---
### 풀이
**60분 이상**  
부분 수열이라는 단어만 보고 dp풀이를 생각했으나, 조건을 유심히 살펴보니 배열의 앞부분 부터 그리디하게 접근해도 되겠다고 생각했다.  
  
i번째 인덱스마다 다음을 체크한다
1. i-1 번째 숫자와 쌍을 이룰 수 있는지 체크한다
 - i번째 숫자는 i-1번째 숫자와 다르면서, i와 같은 i -2번째 숫자가 i - 1번째 숫자와 쌍을 이루고 있지 않아야 한다.
2. i+1 번째 숫자와 쌍을 이를 수 있는지 체크한다
 - i번째 숫자는 i+1번째 숫자와 달라야한다.
 - i+1번째 숫자가 i번째 숫자와 쌍을 이루고 있다는 것을 표시해둔다.


### 코드
```c++
// 10:12 ~ 
#include <string>
#include <vector>
#include <iostream>

using namespace std;

int  solution(vector<int> a) {
    if(a.size() == 1) return 0;
    
    int dp[500001] = {0,};
    int cnt[500001] = {0,};
    
    for(int i =0; i < a.size(); ++i){
        dp[i] = -1;
    }
    
    if(a[0] != a[1]){
        cnt[a[0]] += 1;
        dp[1] = a[0];
    }
    
    for(int i = 1; i < a.size() - 1; ++i){
        if(a[i - 1] != a[i] && dp[i - 1] != a[i]){
            cnt[a[i]] += 1;
        }
        else if(a[i + 1] != a[i]){
            cnt[a[i]] += 1;
            dp[i + 1] = a[i];
        }
    }
    
    if(a[a.size()-2] != a[a.size()-1] && dp[a.size()-2] != a[a.size()-1]){
        cnt[a[a.size()-1]] += 1;
    }
    
    int max_cnt = 0;
    
    for(int i =0; i < a.size(); ++i){
        if(cnt[i] > max_cnt) max_cnt = cnt[i];
    }
    
    return max_cnt*2;
}
```