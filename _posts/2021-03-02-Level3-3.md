---
title:  "[프로그래머스] 풍선 터트리기"
excerpt: "월간 코드 챌린지 시즌1"

categories:
  - Algorithm
tags:
  - Programmers
  - failed
comments: false
last_modified_at: 2021-03-02T12:00:00
---
### 문제 설명
일렬로 나열된 n개의 풍선이 있습니다. 모든 풍선에는 서로 다른 숫자가 써져 있습니다. 당신은 다음 과정을 반복하면서 풍선들을 단 1개만 남을 때까지 계속 터트리려고 합니다.

1. 임의의 인접한 두 풍선을 고른 뒤, 두 풍선 중 하나를 터트립니다.
2. 터진 풍선으로 인해 풍선들 사이에 빈 공간이 생겼다면, 빈 공간이 없도록 풍선들을 중앙으로 밀착시킵니다.

여기서 조건이 있습니다. 인접한 두 풍선 중에서 번호가 더 작은 풍선을 터트리는 행위는 최대 1번만 할 수 있습니다. 즉, 어떤 시점에서 인접한 두 풍선 중 번호가 더 작은 풍선을 터트렸다면, 그 이후에는 인접한 두 풍선을 고른 뒤 번호가 더 큰 풍선만을 터트릴 수 있습니다.  

당신은 어떤 풍선이 최후까지 남을 수 있는지 알아보고 싶습니다. 위에 서술된 조건대로 풍선을 터트리다 보면, 어떤 풍선은 최후까지 남을 수도 있지만, 어떤 풍선은 무슨 수를 쓰더라도 마지막까지 남기는 것이 불가능할 수도 있습니다.  

일렬로 나열된 풍선들의 번호가 담긴 배열 a가 주어집니다. 위에 서술된 규칙대로 풍선들을 1개만 남을 때까지 터트렸을 때 최후까지 남기는 것이 가능한 풍선들의 개수를 return 하도록 solution 함수를 완성해주세요.

### 제한사항
- a의 길이는 1 이상 1,000,000 이하입니다.
- a[i]는 i+1 번째 풍선에 써진 숫자를 의미합니다.
- a의 모든 수는 -1,000,000,000 이상 1,000,000,000 이하인 정수입니다.
- a의 모든 수는 서로 다릅니다.

---
### 풀이
**실패**  
하나의 풍선 기준으로 왼쪽에서의 가장 작은 값과 오른쪽에서의 가장 작은 값이 남도록 풍선을 터뜨릴 수 있는데, 이 때 더 작은 풍선을 터뜨릴 기회를 1번 쓸 수 있다고 해도 두 값 모두 기준값보다 작으면 해당 풍선은 절대 남길 수 없다. 이 사실을 30분 정도 고민한 뒤 깨달았는데, 정답까지 나아가지는 못 했다. 기준이 한칸 오른쪽으로 갈 때마다 왼쪽의 가장 작은값은 쉽게 구할 수 있지만, 오른쪽에서 가장 작은 값은 탐색이 또 이뤄지기 때문이다. 기존의 가장 작은 값을 만났을 때만 탐색하도록 했지만 효율성 검사를 통과하지 못했고, 결국 풀이를 찾게 되었다. 다른 풀이에서는 dp를 이용하여 인덱스마다 최소값을 선형시간내로 구하는 것을 볼 수 있었다.


### 코드
```c++
// 12:45 ~ 
#include <string>
#include <vector>
#include <algorithm>

using namespace std;

int solution(vector<int> a) {
    int ldp[1000000];
    int rdp[1000000];
    int cnt = 0;
    ldp[0] = a[0];
    for(int i = 1; i < a.size(); ++i){
        ldp[i] = min(ldp[i - 1], a[i]);
    }
    
    rdp[a.size() - 1] = a[a.size() - 1];
    for(int i = a.size() - 2 ; i >=0; --i){
        rdp[i] = min(rdp[i + 1], a[i]);
    }
    
    for(int i =0; i < a.size(); ++i){
        if(a[i] <= ldp[i] || a[i] <= rdp[i]) ++cnt;
    }
    return cnt;
}
```